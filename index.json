[{"categories":null,"content":"前段时间购买了@piglei 的《Python 工匠》，现在已经看了 1/3 了，这本书的行文的确是流畅，看起来很舒服，对于 Python 的高阶用法的建议和说明也都非常的不错，我打算开一篇博文单独记录一下，一些自己比较容易遗漏或者忘记的一些知识点。 ","date":"2022-04-05","objectID":"/python-books/:0:0","tags":null,"title":"03.关于《Python 工匠》的摘要笔记","uri":"/python-books/"},{"categories":null,"content":"近期在使用 SQLAlchemy 读取大批量数据的时候，遇到了一个问题，因为数据量过大而查询进程被 Kill 的问题，就想到了使用生成器或者单个请求拆分多次查询的方法。在 github 上找到了一篇 Wiki，照着 Wiki 中的方式，成功解决了 SQLAlchemy 查大数据失败的问题。 这篇 Wiki 文章比较短小，英文读起来也不吃力，但想着还是顺便练习一下翻译，水一篇博客好了。 ","date":"2022-04-02","objectID":"/sqlalchemy-rangequery/:0:0","tags":null,"title":"02.[译文] RangeQuery and WindowedRangeQuery","uri":"/sqlalchemy-rangequery/"},{"categories":null,"content":"译文： Todo ","date":"2022-04-02","objectID":"/sqlalchemy-rangequery/:0:1","tags":null,"title":"02.[译文] RangeQuery and WindowedRangeQuery","uri":"/sqlalchemy-rangequery/"},{"categories":null,"content":"原文： 原文链接：RangeQuery-and-WindowedRangeQuery： RangeQuery and WindowedRangeQuery The goal is to select through a very large number of rows that’s too large to fetch all at once. Many DBAPIs pre-buffer result sets fully, and otherwise it can be difficult to keep an active cursor when using an option like psycopg2’s server side cursors. The usual alternative, i.e. to page through the results using LIMIT/OFFSET, has the downside that the OFFSET will scan through all the previous rows each time in order to get to the requested row. To overcome this, there are two approaches to page through results without using OFFSET. The simplest is to order the results by a particular unique column (usually primary key), then fetch chunks using LIMIT only, adding a WHERE clause that will ensure we only fetch rows greater than the last one we fetched). This will work for basically any database backend and is illustrated below for MySQL. The potential downside is that the database needs to sort the full set of remaining rows for each chunk, which may inefficient, even though both recipes presented here assume the sort column is indexed. However, the approach is very simple and can likely work for most ordinary use cases for a primary key column on a database that does not support window functions. def windowed_query(q, column, windowsize): \"\"\"\"Break a Query into chunks on a given column.\"\"\" single_entity = q.is_single_entity q = q.add_column(column).order_by(column) last_id = None while True: subq = q if last_id is not None: subq = subq.filter(column \u003e last_id) chunk = subq.limit(windowsize).all() if not chunk: break last_id = chunk[-1][-1] for row in chunk: if single_entity: yield row[0] else: yield row[0:-1] if __name__ == \"__main__\": from sqlalchemy import Column, Integer, create_engine from sqlalchemy.orm import Session from sqlalchemy.ext.declarative import declarative_base import random Base = declarative_base() class Widget(Base): __tablename__ = \"widget\" id = Column(Integer, primary_key=True) data = Column(Integer) e = create_engine(\"mysql://scott:tiger@localhost/test\", echo=\"debug\") Base.metadata.drop_all(e) Base.metadata.create_all(e) # get some random list of unique values data = set([random.randint(1, 1000000) for i in range(10000)]) s = Session(e) s.add_all([Widget(id=i, data=j) for i, j in enumerate(data, 1)]) s.commit() q = s.query(Widget) for widget in windowed_query(q, Widget.data, 1000): print(\"data:\", widget.data) A more elaborate way to do this, which allows that the table rows are fully sorted only once, is to use a window function in order to establish the exact range for each “chunk” ahead of time, and then to yield chunks as rows selected within that range. This works only on databases that support windows functions. This recipe has been on the SQLAlchemy Wiki for a long time but it’s not clear how much advantage it has over the previous simpler approach; both approaches should be evaluated for efficiency for a given use case. import sqlalchemy from sqlalchemy import and_, func def column_windows(session, column, windowsize): \"\"\"Return a series of WHERE clauses against a given column that break it into windows. Result is an iterable of tuples, consisting of ((start, end), whereclause), where (start, end) are the ids. Requires a database that supports window functions, i.e. Postgresql, SQL Server, Oracle. Enhance this yourself ! Add a \"where\" argument so that windows of just a subset of rows can be computed. \"\"\" def int_for_range(start_id, end_id): if end_id: return and_( column\u003e=start_id, column\u003cend_id ) else: return column\u003e=start_id q = session.query( column, func.row_number().\\ over(order_by=column).\\ label('rownum') ).\\ from_self(column) if windowsize \u003e 1: q = q.filter(sqlalchemy.text(\"rownum %%%d=1\" % windowsize)) intervals = [id for id, in q] while intervals: start = intervals.pop(0) if intervals: end = intervals[0] else: end = None yield int_for_range(start, end) def windowed_query(q, column, windowsize): \"\"\"\"Break a Qu","date":"2022-04-02","objectID":"/sqlalchemy-rangequery/:0:2","tags":null,"title":"02.[译文] RangeQuery and WindowedRangeQuery","uri":"/sqlalchemy-rangequery/"},{"categories":null,"content":"做为混迹互联网行业十几年的中年人，曾经搭建好几次的博客以及微信公众号，但实际上并未保持持续写博客的状态，实际上在过往写过一部分文章，都零散的分散在电脑的各个角落里面。 如今再一次用 hugo 以及现成的 LoveIt 主题搭建了一个博客，那么，接下去除了写点新的东西以外，几篇老文章到时候也陆陆续续在这里露露面好了。 ","date":"2022-04-02","objectID":"/first_post/:0:0","tags":null,"title":"01.博客开篇","uri":"/first_post/"}]